# 8월 20일

# 저는 큐 구현 잘 못 하겠는데요?
> 하는 사람을 위한 간단한 버전 코드
```buildoutcfg
q = []  # 비어있는 큐 생성
q.append(1) # enq(1)
q.append(2) # enq(2)
q.append(3) # enq(3)

q.pop(0)
q.pop(0)
q.pop(0)
# front, rear 등의 개념 없이 간단하게 큐를 비슷하게 구현해볼 수 있음.
```

# 간단한 큐 구현의 예시
```buildoutcfg
front = rear = -1
q = [0] * 10

rear += 1   # enq(1)
q[rear] = 1
rear += 1   # enq(2)
q[rear] = 2
rear += 1   # enq(3)
q[rear] = 3

front += 1  # deq()
print(q[front])
front += 1  # deq()
print(q[front])
front += 1  # deq()
print(q[front])
```

# 원형 큐
> 원소를 계속 채워가고 없앨 때, 앞에 빈 공간이 생긴다.
> 원형 큐를 사용하면 그 빈 공간도 활용할 수 있게 된다.

# 너비 우선 탐색
## "BFS를 설명해보세요."
> "큐를 이용하는 탐색법입니다."라고 대답하면 반만 맞는 대답.
>> **"시작점에 인접한 정점들을 모두 처리하고, 인접했던 정점들을 다시 시작점으로 하여 차례로 처리하는 탐색 방법입니다.** 이때, 필요한 방법이 큐입니다."라고 대답하면 가장 좋은 대답.

# 너비 우선 탐색의 예시
```buildoutcfg
7 8
4 2 1 2 1 3 5 2 4 6 5 6 6 7 3 7
```

```
이렇게 너비우선탐색 (BFS, Breadth First Search) 방식으로 문제를 풀 때에는
1. visited 생성 (최단 거리를 찾는 문제일 때는 시작점에서 멀수록 +1).
2. 비어있는 큐 생성, 시작점 인큐.
3. 인큐 표시 (시작점의 visited 플래그를 1로 바꾸는 걸 말하는 듯?).
4. 이하 반복.
5.    디큐 (큐.pop(0)).
6.    방문해서 해야될 일 수행 (인접한 장소 차례대로 방문 등).
7.    이때, 방문한 장소가 인접하고 미방문 상태라면,
8.    그 장소를 인큐하고 인큐 표시 (큐에 추가하고 visited 플래그도 0이 아닌 수로 바꾸는 걸 말하는 듯?).
> 여기까지의 논리 구조를 파악하고 기억해두면 좋음. 다른 문제에도 적용 가능.
```

# 트리

- 다음 용어는 알아두면 좋음.
    - **노드의 차수**: 노드에 연결된 자식 노드의 수.
    - **트리의 차수**: 트리에 있는 노드의 차수 중에서 가장 큰 값.
        - 트리의 차수와 높이는 다른 개념이니 주의하자.
    - **말 노드 (리프 노드)**: 차수가 0인 노드. 자식 노드가 없는 노드.
    - **이진 트리**: 모든 노드들이 2개의 서브트리를 갖는 특별한 형태의 트리.
        - 각 노드가 자식 노드를 최대한 2개까지만 가질 수 있는 트리.
    - **완전 이진 트리**: 높이가 h이고 노드 수가 n개일 때, 포화 이진 트리의 노드 번호 1번부터 n번까지 빈 자리가 없는 이진 트리 (단, 2^h <= n <= 2^(H+1)-1)
        - 이진 트리 중에서도, 트리의 가장 아래 줄을 제외한 나머지 모든 노드가 반드시 2개씩 자식 노트를 가지고 있는 트리를 말하는 듯.
    


    




