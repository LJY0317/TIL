함수 이름이 is면 반환값이 true/faulse겠구나, boolean 값이겠구나 예상해볼 수 있습니다.
1. 교재에 있는 method들은 중요해서 다음 거고 그 나머지는 ㄱㅊ

# 11페이지: 메서드 method
  - **객체**에 속한 함수
    > 프로그래밍에서 메서드(Method)는 객체(Object)가 특정 작업을 수행하도록 정의된 함수
  - 클래스(class) 내부에 정의되는 함수.


교재ㅐ 21 페이지의 .issupper(x), islower(x)안의 x는 잘못 입력한 거임. 그냥 x는 지워주세요.

24페이지: [,count]는 이게 문법이라는 걸 표시하기 위한 문법. 실제로 코드 안에 이거를 쓸 필요는 없음. '선택 인자'임
24페이지: 마지막 줄의 , 1은 **이 숫자만큼 바꾼다**는 의미. 엔 번째의 단어를 바꾼다는 의미가 아님. 헷갈리지 않게 주의하자.

25페이지: .strip()에서 ()안에 아무 것도 안 넣으면 기본적으로 공백이 제거됨. 이 안에 문자를 넣어봐서, 문자가 제거되는지, 얼마나 제거되는지 이런 거 직접 확인해보자.
26페이지:sep은 separate라는 의미. ()안에 아무 것도 안 넣으면 공백을 통해서 그걸 기준으로 구분함. 안에 특정 문자를 넣으면 그걸 기준으로 구분함.
> 예를 들어 .split(,)을 쓰면 ,를 기준으로 문자열을 나눔. 원래 문자열에 있던 ','는 소멸함. 대신 ()을 사용할 때는 공백이 제거되었지만, 이 경우에는 문자열에 공백이 남음.

27페이지: join은 리스트 안에 있는 여러 개의 문자열을 하나로 이음 ''안에 들어간 문자를 통해 하나로 이름. join과 split은 반대의 결과가 나온다고 생각하면 편함.

30페이지: 리스트 값 추가 및 삭제 메서드:여기에는 왜 새 문자열을 반환한다 라는 문구가 없을까?
여기서 추측할 수 있는 건 리스트를 조작할 때는 원본을 조작한다, 라는 걸 유추할 수 있다.
이거를 통해 또 **반환값이 없다**라는 걸 유추해볼 수 있다.
> 가장 비슷한 건 print. print() 역시 출력만 할 뿐 그 자체로 반환값이 있는 건 아니었다.
>> 리스트 값 추가 및 삭제 메서드는 원본을 바꾸는 것이다. '아 그러면 반환값이 없겠구나', 이걸 꼭 이해해야 한다.

31페이지: .append(x)에서 x 안에 여러 개의 항목을 동시에 추가할 수 있을까? 직접 실습해서 알아보라.

# print(my_list.apeend(5)) 를 하면 뭐가 출력될까?
> 정답은 None이다. append()자체는 값을 반환하지 않아서 출력해도 아무 것도 안 나온다. 이걸 꼭 알아두자.

33페이지: append()와 expend()의 차이점:
> append()는 값을 풀어서 넣는 게 아니라, 그 값을 통째로 집어넣음.
>> 리스트 안에 append로 리스트를 넣으면, 리스트 안에 리스트가 들어간 형태가 됨.
> 반복 가능한 객체가 아니면 추가 불가.
**반복 가능한 객체**가 무엇인지 알아두자. (int(100)도 반복 불가능한 객체일까?)

38페이지: l.index(x)는 세는 거네? 그러면 반환값이 있겠다
l.count(x) 이것도 센 뒤에 결과값을 알려줘야겠네? 그러면 반환값이 있겠다, 이런 식으로 유추해보자.

39페이지: index는 찾고자하는 그 값을 그대로 반환하는 게 아니라 그 값이 위치한 순서를 알려준다는 걸 알아두자.

40페이지?: reverse는 리스트 안의 항목들을 역순으로 정렬한다??? 틀리다. 꼭 알아두자!!!! 정렬을 하는 건 아니고 역순으로 변경을 할 뿐이다.
43페이지: sort 이게 바로 정렬할 때 쓰는 함수임. 내림차순을 할 때는 .sort(reverse=True) 이렇게 써야 함.
> 아 sort() 안에는 reverse = False가 기본 인자로 있었겠구나 이걸 깨달을 수 있다.
>> sort()를 출력해봤자 None이 나올 뿐이다. 왜냐면 이건 원본을 바꾸는 함수이기 때문이다~ 라는 것도 유추해보자.

**reverse는 역순으로 뒤집을 뿐 정렬은 아니고, sort가 정렬이라는 걸 알아두자!**

60페이지: 얇은 복사의 한계: a를 b에 얇은 복사한 뒤, b의 리스트 안에 있는 리스트를 바꾸면 a까지 똑같이 같이 복사된다.

81페이지: .sort()와 sorted()의 미묘한 활용법 차이를 알아두자.





---
# 5차

- 1번 문제:
문자열도 순회가 가능하다!
data_1 = '123'일 때,
  for i in data_1:
    new_list.append(i)
를 해서, ['1', '2', '3']을 얻어낼 수 있다!

또한,
numbers = '1 2 3'일 때,
new_list = numbers.split()를 해서, ['1', '2', '3']을 얻어낼 수 있다.

# for문 안에서 print()가 여러 번 반복될 때,
각 print마다 줄바꿈이 되지 않고 한번에 붙여쓰는 법
**print(  ,end = '')**을 사용한다.
```
for num in [1:6]:
    print(num, end='')
출력결과 : 12345
```

3번 문제:
```
print(''.join(result))
```
> .join은 이렇게 print()안에 바로 집어넣을 수 있다. 문법이 특이하게 생겼으니 기억해두자.


----------------------------
# 250729 강의

9페이지: dict.get('key')와
dict['key']를 이용할 때의 차이점:
> 올바른 key를 입력했을 때는 상관 없음.
근데 dict 내부에 없는 key를 입력했을 때,
get 함수를 쓰면 함수가 정상작동함 (None 또는 설정한 디폴트 값이 나옴)
근데 dict['key']을 쓰면 함수가 에러남.
일부러 에러나는 걸 유도해야될 때가 있으니, 한 쪽이 한 쪽의 상위호환 관계인 건 아님.

12페이지:
.keys(), .values(), .items() 함수를 이용해
딕셔너리에 값을 뽑아내는 거 앞으로 자주 쓰게 될 테니 알아두자.

15페이지: .get()과 .setdefault()의 차이점
> 키를 통해서 값을 얻어오는 건 똑같음.
근데 get은 그 키가 없으면 거기서 끝인데,
setdefault는 키가 없으면 그 키와, 같이 지정한 디폴트까지도 딕셔너리에 추가해줌.
>> setdefault는 get에 추가 기능이 달렸다고 생각하면 됨.
**궁금증: 그러면 setdefault는 반드시 default에 어떤 내용이 들어갈지까지 같이 선언해야 하는가?**

16페이지: .update()를 이용해 기존 딕셔너리에 새로운 딕셔너리를 덮어씌울 경우,
같은 이름의 기존 키가 존재했다면, 그건 덮어쓴다.
물론 없던 키와 밸류를 같이 추가할 수도 있다.

19페이지:
만약 문제에서 [리스트의 순서를 유지한 상태에서 중복된 항목들을 제거하라]
이러면 리스트->세트->리스트 변환을 이용해 풀면 안 됨.
세트로 변환할 때 순서가 사라지기 때문.

27페이지: 세트에서 .remove()와 .discard()
> .discard()는 없는 걸 지울 때 에러가 나는 게 아니라 그냥 결과가 안 나옴.

40페이지: set에서 pop()을 할 때 **'임의의 요소'가 제거된다는 건 '무작위'로 제거한다는 의미는 아니다.**


# 어떤 객체가 특정 자료형일 때 다음으로 진행하고 싶을 때
## isinstance()를 사용하자
✅ isinstance() 함수란?
isinstance()는 "is instance of", 즉

"이 객체가 특정 클래스(자료형)의 인스턴스인가?"
를 묻는 함수입니다.

📘 용어 풀이
is → ~이다

instance → 인스턴스 (객체), 어떤 클래스에서 만들어진 개별 객체

isinstance(obj, class) →

"obj가 class의 인스턴스인가?"
즉, obj가 class(예: dict, list, int 등)의 자료형인지 확인합니다.


✅ 예제
```
a = {'name': 'Alice'}

print(isinstance(a, dict))   # True
print(isinstance(a, list))   # False

b = [1, 2, 3]
print(isinstance(b, list))   # True

c = 42
print(isinstance(c, int))    # True
```


✅ 여러 타입 동시에 확인하기
```
x = (1, 2, 3)
print(isinstance(x, (list, tuple)))  # True → 튜플이나 리스트이면 True
```